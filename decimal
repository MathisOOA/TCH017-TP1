; Nom du fichier PEP/8 ? déterminer !
;
;    AUTEUR-S    : Justin Fiset, Vincent Moreau-Benoit, Mathis Odjo'o Ada, Nikola Sunjka
;    DATE        : 10/11/2024 
;    ?QUIPE      : Gr-01-Equipe 08
;    DESCRIPTION :
;
;      Ce programme a pour objectif de lire une s?quence binaire de 32 bits, entr?e au clavier
;      par l'utilsateur, repr?santant un nombre flottant au format IEEE 754 pour ensuite 
;      le convertir en sa repr?sentation d?cimale.       (Trop long ?)



TAILLE:  .EQUATE 32 ; la taille du tableau en byte
N_EXPO:  .EQUATE 8 ; Le nombre de bit qui servent ? repr?senter l'exposant

BIAIS_EX:.EQUATE 127 ; le biais de l'exposant selon la norme IEEE754
NEGATIF: .EQUATE 1 ; la valeur du bit de signe si le nombre est n?gatif

         
; TODO IL FAUT FIX LA MANI?RE DONT LES IF SONT FAIT ET LES FAIRES COMME L'EXAMPLE DU PROF
main:    STRO msg_inpt, d ; On d?crit ? l'utilisateur ce qu'il tape sur le clavier
         
         LDX cpt, d ; On s'assure que l'indice est bien initialement ? 0
         for_1:  CPX TAILLE, i ; if(x == TAILLE)
                 BREQ end_1   ;     a_end_1() 
         
                
                 CHARI v, d ; On demande un char

                 ; Si l'entr?e de l'utilisateur est un 0 ou un 1 (ascii)  
                 LDBYTEA v, d   

                 CPX 0, i ; if(x==0)
                 BREQ sign_Set

                 CPA '0', i
                 BREQ add_0 ; on ajoute au tableau la valeur 0 
                 CPA '1', i
                 BREQ add_1 ; on ajoute au tableau la valeur 1
                 BR for_1 ; Sinon, on a pas ce que l'on veux, on redemande 
                 
                 
                 ; Si les conditions sont satisfaitent, on ajoute la valeur au tableau
                 add_0:      LDBYTEA 0, i   ; tab[x] = 0 -> on met la valeur entrée dans le tableau 
                             STBYTEA tab, x 
                             BR run_1 

                 add_1:      LDBYTEA 1, i   ; tab[x] = 0 -> on met la valeur entr?e dans le tableau
                             STBYTEA tab, x 
                             BR run_1

                 run_1:      ADDX 1, i ; on incr?mente le compteur car valeur ok
                             STX cpt, d

                             BR for_1 ; on relance la boucle  

                 sign_Set:CHARO '\n', i ; // TODO ENLEVER
                          CPA '1', i
                          BREQ sign_Neg ; Le bit de signe est négatif 
                          LDA 0, i
                          STBYTEA bit_Val, d
                          BR add_0

                sign_Neg: LDA 1, i
                          NEGA
                          BR SUITE

                SUITE: STA bit_Val, d
                       DECO bit_Val, d ; // TODO ENLEVER
                       BR sign_Set                     ; Cette ligne n'est pas logique 
      
         
         end_1:  LDX N_EXPO, i ; On va chercher le bit le plus loin de l'exposant
                 
                

         ; CALCUL DE L'EXPOSANT
         for_2:  CPX 0, i
                 BREQ end_2

                 LDBYTEA tab, x ; Si la valeur ? tab[x] == 1
                 CPA 1, i   ;    -> On ajoute 2^x ? la valeur de l'exposant
                 BREQ add_expo 
                 BR run_2 ; Sinon on relance directement la boucle 

                 add_expo:   LDA expo, d ; expo += exp_bit
                             ADDA exp_bit, d
                             STA expo, d

                 run_2:      LDA exp_bit, d  ; on double la valeur de expo_bit
                             ADDA exp_bit, d ; CODE: exp_bit += exp_bit
                             STA exp_bit, d

                             SUBX 1, i ; puisque l'on part de la fin de l'exposant on d?cr?mente
                             BR for_2 ; on relance la boucle

         end_2:  LDA expo, d
                 SUBA BIAIS_EX, i
                 STA expo, d
                 STRO test, d 
                 DECO expo, d ; Test pour afficher l'exposant // TODO ENLEVER
                 CHARO '\n', i; // TODO ENLEVER
                 STRO test, d ; // TODO ENLEVER
                 STOP



                 
                 
v:       .BYTE 0 ; la valeur de l'entr?e de l'utilisateur
exp_bit: .WORD 1 ; la valeur de l'exposant li? ? un bit; Ex: 2^n 
expo:    .WORD 0 ; la valeur de l'exposant
bit_Val: .WORD 0 ; 
cpt:     .WORD 0 


test:    .ASCII "\nTest : " ; // TODO ENLEVER 

i_tab:   .WORD 0 ; l'index dans le tableau
tab:     .BLOCK 32
signe:   .BYTE 0 ; 1 ou 0

msg_inpt:.ASCII "Entrez 32 valeurs (0 ou 1) qui représentent un nombre à virgule flottante: \x00"


.END ; on ferme le programme
